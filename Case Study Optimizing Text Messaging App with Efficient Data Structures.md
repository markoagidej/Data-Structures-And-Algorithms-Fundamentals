# Problem Statement: The existing text messaging app experiences slowdowns and inefficiencies as the number of messages grows. The challenge is to identify and implement suitable data structures to manage conversations, support quick message retrieval, and facilitate real-time updates, ensuring a seamless user experience.

## Task 1: Message Storage and Retrieval:
In a basic messaging app we have the user, user contacts, and messeges the user has with each contact. An assumption would be that each conversation with a contact is grouped with that contact, and messages are displayed in chronological order. For any given contact, the user will probably only see the content of a message, and maybe a time stamp, but there may be other data contained in each message utilized by the app. For whatever object is used to contain a message and other data, a List could be used and any new messages will be appended to the List. When retrieving messages we can increment backwards through the list for however many messages we want before loading the next batch. A List is advantagous over a Linked List in this case since we are only append to the end of the list. Messages will never be inserted into the middle of the conversation, which is where we would see the benefits of a Linked List. A normal List is more efficient only at modifying the end of the list, which is exactly what we are doing here.

## Task 2: Real-Time Updates:
We want messages to be recieved as quickly as possible. We can immediately eliminate normal polling as an option for 2 main reasons. (1) If we poll but there is no new data to retrieve, it is a wasted operation. (2) The frequency we would need to poll in order to have near instant delivery is infeasable. Long-polling addresses these 2 concerns by simply waiting for a new data event to be triggered on the server before sending a response. However long-polling has different issues regarding multiple connections and synchronicity. This can lead to messages appearing out of order, or false positives confirmations regarding new data packets being sent or recieved. Websockets adresses the issues of both polling types. Websockets connections do not automatically recover when errors arise, however this can be manually handled in code. Websockets are the best choice for real-time updates.

## Task 3: Conversation List Management:
Typically when displaying all message from all contacts, the most recently active conversations will be displayed first. The list of contacts specifically should be a Linked List since this needs to remain ordered, but the order is constantly changing. If contact searching is required, we may use a helper dictionary where contact names are keys, which are what would be searched.